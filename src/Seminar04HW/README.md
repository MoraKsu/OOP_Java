### Домашнее задание 6 семинара

Принципы SOLID к этому:

- Принцип единственной ответственности (Single Responsibility Principle):

Этот принцип гласит, что каждый класс должен иметь только одну причину для изменения. Давайте посмотрим, где мы можем 
применить этот принцип:

Teacher: Класс Teacher представляет учителя и имеет только одну ответственность - хранить информацию о имени учителя. 
Он не должен быть ответственным за сортировку или другие операции. Он следует этому принципу.

TeacherService: Этот класс отвечает за управление списком учителей. Он также следует принципу единственной 
ответственности, потому что он занимается только операциями добавления и получения учителей.

TeacherController и TeacherController2: Оба класса контроллеров также следуют этому принципу. Они отвечают за 
взаимодействие с сервисом и несут ответственность за отображение данных или управление бизнес-логикой.

- Принцип открытости/закрытости (Open/Closed Principle):

Этот принцип утверждает, что классы должны быть открыты для расширения, но закрыты для модификации. Давайте посмотрим, 
как это может быть применено:

UserComparator: Этот класс отвечает за сортировку списка пользователей. Он закрыт для модификации, потому что его не 
нужно изменять при добавлении новых типов пользователей. Он открыт для расширения, так как новые типы пользователей 
могут быть сортированы, реализуя интерфейс Comparable.

- Принцип подстановки Барбары Лисков (Liskov Substitution Principle):

Этот принцип гласит, что объекты в программе должны быть заменяемыми экземплярами их супертипов без изменения 
корректности программы. В этом проекте принцип подстановки Барбары Лисков не так сильно проявляется, но он применим к 
интерфейсу UserService и его реализации TeacherService. Любая реализация UserService, такая как TeacherService, должна 
предоставлять те же методы с теми же сигнатурами и должна сохранять их контракты.

- Принцип разделения интерфейса (Interface Segregation Principle):

Этот принцип утверждает, что клиенты не должны зависеть от интерфейсов, которые они не используют. В этом проекте 
интерфейс UserService может быть немного нарушен, потому что он имеет метод addTeacher, который не используется в 
контроллерах. Для соблюдения этого принципа мы можем разделить интерфейс на два: один для операций с обычными 
пользователями и один для операций с учителями. Это поможет избежать необходимости реализации ненужных методов.

- Принцип инверсии зависимостей (Dependency Inversion Principle):

Этот принцип гласит, что модули верхнего уровня не должны зависеть от модулей нижнего уровня, а оба типа должны зависеть 
от абстракций. В нашем случае, классы контроллеров зависят от интерфейса UserService, что соответствует этому принципу. 
Также в конструкторах контроллеров используется внедрение зависимостей, что позволяет передавать различные реализации 
UserService, не изменяя контроллеры.